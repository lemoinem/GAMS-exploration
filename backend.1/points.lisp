#|
Licensed under 3-clause BSD License:
Copyright Â© 2010, Mathieu Lemoine
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:
* Redistributions of source code must retain the above copyright
notice, this list of conditions and the following disclaimer.
* Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.
* Neither the name of Mathieu Lemoine nor the
names of contributors may be used to endorse or promote products
derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY Mathieu Lemoine ''AS IS'' AND ANY
EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL Mathieu Lemoine BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
\(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION\) HOWEVER CAUSED AND
ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
\(INCLUDING NEGLIGENCE OR OTHERWISE\) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
|#

(cl:in-package #:gams-dynamic-sets)

(defstruct (initial-point
             (:constructor %make-initial-point
                           (strategy set-point result-point set-index)))
  "GAMS initial point.
Some restrictions apply to the various slots:
- if a :derived strategy has been used to generated this point, result-point must not be null;
- if a :family  strategy has been used to generated this point, set-index    must not be null."
  (strategy     nil :read-only t :type strategy)
  (set-point    nil :read-only t :type set-point)
  (result-point nil :read-only t :type (or null result-point))
  (set-index    nil :read-only t :type (or null unsigned-byte))
  (file-name    nil              :type (or null string)))

(defun initial-point-set (instance)
  "Returns the set whose size has been augmented
to generate the set-point at which this initial-point has been generated."
  (declare (type initial-point instance))
  (when (initial-point-result-point instance)
    (let ((old-set-point (initial-point-set-point
                          (result-point-initial-point
                           (initial-point-result-point instance))))
          (new-set-point (initial-point-set-point instance)))
      (loop
         for set in *sets*
         when (/= (gethash set old-set-point)
                  (gethash set new-set-point))
         return (the dynamic-set set)))))

(defun make-initial-point (strategy set-point
                           &optional result-point set-index)
  "Create a new initial point."
  (declare (type strategy  strategy)
           (type set-point set-point)
           (type (or null result-point) result-point)
           (type (or null unsigned-byte) set-index))
  (when (and (member (strategy-derivation strategy) '(:derived :family))
             (null result-point))
    (error "a derived result point must be derived from a previous point"))
  (when (and (eql (strategy-derivation strategy) :family)
             (null set-index))
    (error "a result point extracted from a family must have an iteration index"))
  (%make-initial-point strategy set-point result-point set-index))

(defstruct (point-key
             (:constructor make-point-key
                           (name &rest %indices
                                 &aux (indices (mapcar (lambda (indice)
                                                         (the string indice))
                                                       %indices)))))
  "A point key represents the name of a GAMS variable and an instanciation of its indices."
  (name    nil :read-only t :type string)
  (indices nil :read-only t :type list))

(defun point-p (point)
  "Returns whether point is a instance of point.
A point is an hash-table in which:
- each key is a point-key;
- each value is a real."
  (and
   (every #'point-key-p (hash-table-keys point))
   (every (rcurry #'typep 'real) (hash-table-values point))))

(deftype point ()
  "A point is an instanciation of the variables of a GAMS model."
  '(satisfies point-p))

(defstruct (result-point
             (:constructor %make-result-point
                           (initial-point
                            solver solver-status solver-iteration solver-time
                            objective-value point)))
  "A result-point is a point generated by a GAMS solver.
objective-value and point may be null only if ERRONEOUS-POINT-P retruns t."
  (initial-point    nil :read-only t :type initial-point)
  (solver           nil :read-only t :type string)

  (solver-status    nil :read-only t :type unsigned-byte)
  (solver-iteration nil :read-only t :type unsigned-byte)
  (solver-time      nil :read-only t :type (real 0))
  (objective-value  nil :read-only t :type (or real null))
  (point            nil :read-only t :type (or point null)))

(defun erroneous-point-p (solver-status)
  "An erroneous point is a point for which the solver returns an error.
Status > 9."
  (declare (unsigned-byte solver-status))
  (> solver-status 9))

(defun feasible-point-p (point)
  "A feasible point is a point satisfying all the constraints in the GAMS model."
  (declare (type result-point point))
  (member (result-point-solver-status point)
          '(1 2 7 8)))

(defun make-result-point (initial-point solver
                          solver-status solver-iteration solver-time
                          objective-value point)
  "Creates a new result-point."
  (declare (type initial-point initial-point)
           (type (or null point) point))
  (when (and (or (null objective-value) (null point))
             (not (erroneous-point-p point)))
    (error "infeasibility, non-optimality or unboundability are no excuses for a lack of data"))
  (%make-result-point initial-point solver
                      solver-status solver-iteration solver-time objective-value point))
